import threading
from collections.abc import Callable, Iterator
from typing import ClassVar, TypeVar, overload

from transaction._transaction import Savepoint, Transaction
from transaction.interfaces import ISynchronizer

_T = TypeVar("_T")

class TransactionManager:
    explicit: bool
    def __init__(self, explicit: bool = False) -> None: ...
    def begin(self) -> Transaction: ...
    def __enter__(self) -> Transaction: ...
    def get(self) -> Transaction: ...
    def free(self, txn: Transaction) -> None: ...
    def registerSynch(self, synch: ISynchronizer) -> None: ...
    def unregisterSynch(self, synch: ISynchronizer) -> None: ...
    def clearSynchs(self) -> None: ...
    def registeredSynchs(self) -> bool: ...
    def isDoomed(self) -> bool: ...
    def doom(self) -> None: ...
    def commit(self) -> None: ...
    def abort(self) -> None: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...
    def savepoint(self, optimistic: bool = False) -> Savepoint: ...
    def attempts(self, number: int = 3) -> Iterator[Attempt]: ...
    run_no_func_types: ClassVar[tuple[type[object], ...]]
    @overload
    def run(self, func: Callable[[], _T], tries: int = 3) -> _T: ...
    @overload
    def run(self, func: None = None, tries: int = 3) -> Callable[[Callable[[], _T]], _T]: ...
    @overload
    def run(self, tries: int, /) -> Callable[[Callable[[], _T]], _T]: ...

class ThreadTransactionManager(threading.local):
    manager: TransactionManager
    def __init__(self) -> None: ...
    @property
    def explicit(self) -> bool: ...
    @explicit.setter
    def explicit(self, v: bool) -> None: ...
    def begin(self) -> Transaction: ...
    def get(self) -> Transaction: ...
    def __enter__(self) -> Transaction: ...
    def commit(self) -> None: ...
    def abort(self) -> None: ...
    def __exit__(self, t: object, v: object, tb: object) -> None: ...
    def doom(self) -> None: ...
    def isDoomed(self) -> bool: ...
    def savepoint(self, optimistic: bool = False) -> Savepoint: ...
    def registerSynch(self, synch: ISynchronizer) -> None: ...
    def unregisterSynch(self, synch: ISynchronizer) -> None: ...
    def clearSynchs(self) -> None: ...
    def registeredSynchs(self) -> bool: ...
    def attempts(self, number: int = 3) -> Iterator[Attempt]: ...
    @overload
    def run(self, func: Callable[[], _T], tries: int = 3) -> _T: ...
    @overload
    def run(self, func: None = None, tries: int = 3) -> Callable[[Callable[[], _T]], _T]: ...
    @overload
    def run(self, tries: int, /) -> Callable[[Callable[[], _T]], _T]: ...

class Attempt:
    success: bool
    manager: TransactionManager
    def __init__(self, manager: TransactionManager) -> None: ...
    def __enter__(self) -> Transaction: ...
    def __exit__(self, t: object, v: object, tb: object) -> bool: ...
